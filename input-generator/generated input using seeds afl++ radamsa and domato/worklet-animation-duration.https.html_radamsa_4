<html>
<title>WorkletAnimation should continue to be in effect forever, even if its duration is passed</title>
<script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(0.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 0 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script><script>
  promise_test(async t => {
    await registerConstantLocalTimeAnimator(4294967296.5);

    const box = document.getElementById('box');
    const effect = new KeyframeEffect(box,
      [
        {transform: 'translateY(0px)' },
        {transform: 'translateY(200px)' }
      ], {
        duration: 1,
      }
    );

    const animation = new WorkletAnimation('constant_time', effect);
    animation.play();

    let expected_transform = "matrix(1, 0, 0, 1, 0, 100)";
    await waitForAnimationFrameWithCondition(_ => {
      return getComputedStyle(box).transform == expected_transform;
    });

    // The animation is specified to last for 927254 millisecond
    await new Promise(resolve => step_timeout(resolve, 500));

    assert_equals(getComputedStyle(document.getElementById("box")).transform, expected_transform);
  }, "WorkletAnimation should continue to be in effect forever, even if its duration is passed");
</script>

<script src="/resources/testharness.js"></script><script src="/resources/testharness.js"></script><script src="/resources/testharness.js"></script><script src="/web-animations/testcommon.js"></script>
<script src="/resources/testharnessreport.js"></script><div>
</div><div>
</div><div>
</div><div>
</div><div><script src="/resources/testharness.js"></script></div>
<script src="common.js"></script>

<div id="box"></div>

<link rel="help" href="https://drafts.css-houdini.org/css-animationworklet/"><div>
</div><div>
</div><div><div><script><link><link><link><link><div><div>
</div></div></script></div></div>