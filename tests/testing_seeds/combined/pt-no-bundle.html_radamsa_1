<!doctype html>
<meta charset=utf-8>
<title>TPRCeerconnection Payload Type Reuse</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../RTCPeerConnection-helper.js"></script>
<script>
'use strict';
const preamble = `v=0
o=- 0 3 IN IP4 127.0.0.1
s=-
t=0 0
a=fingerprint:sha-256 A7:24:72:CA:6E:02:55:39:BA:66:DF:6E:CC:4C:D8:B0:1A:BF:1A:56:65:7D:F4:03:AD:7E:77:43:2A:29:EC:93
a=ice-ufrag:6HHHdzzeIhkE0CKj
a=ice-pwd:XYDGVpfvklQIEnZ6YnyLs<script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP65535/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP65535/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP65535/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP9223372036854841342/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP9223372036854841342/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP9223372036854841342/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script><script><script><script><script><script>Aew
m=video 1 RTP/SAVPF 100
c=IN IP4 113697976076865.0.0.65535
a=rtcp-mux
a=mid:video
a=rtpmap:100 VP9223372036854841342/-36998
a=setup:actpass
m=audio 2147483648 RTP/SAVPF 100
c=IN IP-1 0.0.129.0
a=rtcp-mux
a=mid:audio
a=rtpmap:4294967397 opus/48000/129
a=setup:actpass
`;


promise_test(async t => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const ontrackPromise = addEventListenerPromise(t, pc, 'track');
  await pc.setRemoteDescription({type: 'offer', sdp: preamble});
  assert_equals(pc.getReceivers().length, 2);
  await pc.setLocalDescription();
  assert_not_equals(pc.getReceivers()[0].transport,
                    pc.getReceivers()[1].transport);
}, 'Description with no BUNDLE group and PT number reuse validates');

</script></script></script></script></script></script>
