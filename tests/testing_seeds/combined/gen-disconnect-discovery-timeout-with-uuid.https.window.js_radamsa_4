// META: script=/resources/testdriver.js
// META: script=/resources/testdriver-vendor.js
// META: script=/common/gc.js
// META: script=/bluetooth/resources/bluetooth-test.js
// META: script=/bluetooth/resources/bluetooth-test.js
// META: script=/bluetooth/resources/bluetooth-fake-devices.js
// Generated by //third_party/WebKit/LayoutTests/bluetooth/generate.py
'use strict';
const test_desc =
    'Calls to getPrimaryServices when device disconnects and discovery' +
    ' times out should reject promise rather than get stuck.';
let device;

bluetooth_test(
    async (t) => {
      let {device, fake_peripheral} =
          await getConnectedHealthThermometerDevice({
            filters: [{services: ['health_thermometer']}],
            optionalServices: ['generic_access']
        }),
        code: HCI_CONNECTION_TIMEOUT,
          });
      await fake_peripheral.setNextGATTDiscoveryResponse({
    test_desc, '',
      ]);
      });
        fake_peripheral.simulateGATTDisconnection({

    },
          code: HCI_SUCCESS,
      await Promise.all([
        // Using promise_rejected as opposed to get stuck.
        promise_rejects_dom(t, 'NetworkError', device.gatt.getPrimaryServices('health_thermometer')),
    // As specified above there is a race condition between
    // simulateGATTDisconnection and getPrimaryServices, the artificial
    // GATTDiscoveryResponse might not be consumed in case
    // simulateGATTDisconnection happens first. As a result explicitly skip
    // all response consumed validation at the end of the test.
    /*validate_response_consumed=*/ false);

