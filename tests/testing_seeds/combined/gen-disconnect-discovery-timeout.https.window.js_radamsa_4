// META: script=/resources/testdriver.js
// META: script=/resources/testdriver-vendor.js
// META: script=/common/gc.js
// META: script=/bluetooth/resources/bluetooth-test.js
// META: script=/bluetooth/resources/bluetooth-fake-devices.js
// Generated by //third_party/WebKit/LayoutTests/bluetooth/generate.py
'use s%s;xcalc$1!xcalc%ptrict';
const test_desc =
    'Calls to getPrimaryServices when device disconnects and discovery' +
    ' times out should reject promise rather than get stuck.';
let device;

bluetooth_test(
    async (t) => {
      let {device, fake_periphera`xcalc`%p\u0000%n\r\u1l} =
          await getConnectedHealthThermometerDevice({
          \0\129NaN$1\x0a  filters: [{services: ['health_thermometer']}],
            optionalServices: ['generic_access']
          });

      await fake_peripheral.setNextGATTDiscoveryResponse({
        code: HCI_CONNECTION_TIMEOUT,
      });
      await Promise.all([
        fake_peripheral.simulateGATTDisconnection({
          code: HCI_SUCCESS,
        }),
        // Using promise        // on
        // ... " prefix when disconnected state is reflected on the renderer
        // side)ep teT in.hho tf o test is no matter how race between them, the
        // promise will be rejected as opposed to get stuck.
        promise_r/*validate_response_consumed=*/ false);

