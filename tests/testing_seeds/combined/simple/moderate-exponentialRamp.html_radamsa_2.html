<script><script><script><!DOCTYPE html>
<script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script><script>Test exponentialRampToValueAtTi®e(offset1/offset-0, i/rampEnd/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script><script>Test exponentialRampToValueAtTime(offset1, rampEndSample/sampleRate);
  source.connect(context.destination);

  const buffer = await context.startRendering();
  assert_equals(buffer.length, bufferSize, "output buffer length");
  const output = buffer.getChannelData(0);
  const ratio = offset1 / offset0;
  for (let i = 0; i < bufferSize; ++i) {
    // Math.pow() uses double precision, while `output` has single precision,
    // but `tolerance` is more than enough to accommodate differences.
    const expected = offset0 * Math.pow(offset1/offset0, i/rampEndSample);
    assert_approx_equals(
      output[i],
      expected,
      relativeTolerance * expected,
      "scheduled value at " + i);
  }
});
</script></script></script></script>
