<!doctype html>
<meta charset=utf-8>
<script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script>
<link rel="help" href="https://w3c.github.io/IndexedDB/#index-interface"><title>
</title><script src="/resources/testharness.js"></script><script src="/resources/testharness.js"></script><script src="/resources/testharness.js"></script><script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/support.js"></script>
<title>IndexedDB: IDBIndex getAllKeys() uses [EnforceRange]</title><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script><script>

indexeddb_test(
  (t, db) => {
    const store = db.createObjectStore('store');
    const index = store.createIndex('index', 'keyPath');
  },
  (t, db) => {
    const tx = db.transaction('store', 'readonly');
    const store = tx.objectStore('store');
    const index = store.index('index');
    [NaN, Infinity, -Infinity, -1, -Number.MAX_SAFE_INTEGER].forEach(count => {
      assert_throws_js(TypeError, () => { index.getAllKeys(null, count); },
                       `getAllKeys with count ${count} count should throw TypeError`);
    });
    t.done();
  },
  `IDBIndex.getAllKeys() uses [EnforceRange]`
);
</script>
